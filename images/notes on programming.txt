# Helpful links:

	http://learngitbranching.js.org/ <— Github practice 


# The Basics

## About bits (and what is data?):

Inside the computer’s world, there is only data. You can read data, modify data, create new data—but anything that isn’t data simply does not exist. All this data is stored as long sequences of *bits* and is thus fundamentally alike.

Bits are any kind of two-valued things, usually described as zeros and ones. Inside the computer, they take forms such as a high or low electrical charge, a strong or weak signal, or a shiny or dull spot on the surface of a CD. Any piece of discrete information can be reduced to a sequence of zeros and ones and thus represented in bits.


## Values (what *is* a value?):

A typical modern computer has more than 30 billion bits in its volatile data storage. Nonvolatile storage (the hard disk or equivalent) tends to have yet a few orders of magnitude more.

To be able to work with such quantities of bits without getting lost, you can separate them into chunks that represent pieces of information. In a JavaScript environment, those chunks are called *values*. Though all values are made of bits, they play different roles. *Every value has a type that determines its role*. 

*There are six basic types of values in JavaScript: numbers, strings, Booleans, objects, functions, and undefined values*.

## Different types of Values (Data types):

**Numbers or Whole Numbers (AKA Integers):**
 
Values of the number type are, unsurprisingly, numeric values. In a JavaScript program, they are written as follows:

	13

Use that in a program, and it will cause the bit pattern for the number 13 to come into existence inside the computer’s memory.

JavaScript uses a fixed number of bits, namely 64 of them, to store a single number value. There are only so many patterns you can make with 64 bits, which means that the amount of different numbers that can be represented is limited. For N decimal digits, the amount of numbers that can be represented is 10N. Similarly, given 64 binary digits, you can represent 264 different numbers, which is about 18 quintillion (an 18 with 18 zeros after it). This is a lot.

**Fractional Numbers:**

Not all whole numbers below 18 quintillion fit in a JavaScript number, though. Those bits also store negative numbers, so one bit indicates the sign of the number. A bigger issue is that non-whole numbers must also be represented. To do this, some of the bits are used to store the position of the decimal point. The actual maximum whole number that can be stored is more in the range of 9 quadrillion (15 zeros), which is still pleasantly huge.

Fractional numbers are written by using a dot.

	9.81


**Special Numbers:**

There are three special values in JavaScript that are considered numbers but don’t behave like normal numbers.

The first two are Infinity and -Infinity, which represent the positive and negative infinities. Infinity - 1 is still Infinity, and so on. Don’t put too much trust in infinity-based computation. It isn’t mathematically solid, and it will quickly lead to our next special number: NaN.

NaN stands for “not a number”, even though it is a value of the number type. You’ll get this result when you, for example, try to calculate 0 / 0 (zero divided by zero), Infinity - Infinity, or any number of other numeric operations that don’t yield a precise, meaningful result.

**Strings:**

The next basic data type is the string. Strings are used to represent text. They are written by enclosing their content in quotes.

	"Patch my boat with chewing gum"
	'Monkeys wave goodbye'

Both single and double quotes can be used to mark strings as long as the quotes at the start and the end of the string match.

Strings cannot be divided, multiplied, or subtracted, but the + operator can be used on them. It does not add, but it concatenates—it glues two strings together. The following line will produce the string "concatenate":

	"con" + "cat" + "e" + "nate"

**Boolean values:**

Often, you will need a value that simply distinguishes between two possibilities, like “yes” and “no” or “on” and “off”. For this, JavaScript has a Boolean type, which has just two values: true and false (which are written simply as those words).

The > and < signs are the traditional symbols for “is greater than” and “is less than”, respectively. They are *binary operators*. Applying them results in a Boolean value that indicates whether they hold true in this case.

Strings can be compared in the same way:

	console.log("Aardvark" < "Zoroaster")
	// → true

**Undefined values:**

There are two special values, written *null* and *undefined*, that are used to denote the absence of a meaningful value. *They are themselves values, but they carry no information*.

Many operations in the language that don’t produce a meaningful value (you’ll see some later) yield undefined simply because they have to yield some value.

The difference in meaning between *undefined* and *null* is an accident of JavaScript’s design, and it doesn’t matter most of the time. In the cases where you actually have to concern yourself with these values, I recommend treating them as interchangeable (more on that in a moment).

**SIDE NOTE ABOUT VALUES: Automatic type conversion:**

In the introduction, I mentioned that JavaScript goes out of its way to accept almost any program you give it, even programs that do odd things. This is nicely demonstrated by the following expressions:

	console.log(8 * null)
	// → 0
	console.log("5" - 1)
	// → 4
	console.log("5" + 1)
	// → 51
	console.log("five" * 2)
	// → NaN
	console.log(false == 0)
	// → true

When an operator is applied to the “wrong” type of value, JavaScript will quietly convert that value to the type it wants, using a set of rules that often aren’t what you want or expect. This is called type coercion. So the null in the first expression becomes 0, and the "5" in the second expression becomes 5 (from string to number). Yet in the third expression, + tries string concatenation before numeric addition, so the 1 is converted to "1" (from number to string).

## Operators:

**Arithmetic operators:**
Arithmetic operations such as addition or multiplication take two number values and produce a new number from them. Here is what they look like in JavaScript:

	100 + 4 * 11

The + and * symbols are called operators. The first stands for addition, and the second stands for multiplication. Putting an operator between two values will apply it to those values and produce a new value.

	Addition operator is +  
	Multiplication operator is *  
	Subtraction operator is –
	Division operator is /
	Remainder operator is % - Note: This is tricky

There is one more arithmetic operator, which you might not immediately recognise. The % symbol is used to represent the remainder operation. X % Y is the remainder of dividing X by Y. For example, 314 % 100 produces 14, and 144 % 12 gives 0.
 
Operators also have *precedence*. This means that each operator has a kind of authority to determine which will be executed first (from left to right) when given a conflicting task like the one above.

*Parentheses* are used to wrap certain values to give the computer better instructions on how to execute that statement and in which order of *precedence*:

	(100 + 4) * 11

When operators appear together without parentheses, the order in which they are applied is determined by the *precedence* of the operators.

The / operator has the same precedence as *. Likewise for + and -. When multiple operators with the same precedence appear next to each other, as in 1 - 2 + 1, they are applied left to right: (1 - 2) + 1.


**Unary operators:**

Not all operators are symbols. Some are written as words. One example is the typeof operator, which produces a string value naming the type of the value you give it.

	console.log(typeof 4.5)
	// → number
	console.log(typeof "x")
	// → string

The other operators we saw all operated on two values, but typeof takes only one. Operators that use two values are called binary operators, while those that take one are called unary operators. The minus operator can be used both as a binary operator and as a unary operator.

	console.log(- (10 - 2))
	// → -8


**Binary operators:**

The > and < signs are the traditional symbols for “is greater than” and “is less than”, respectively. They are binary operators. Applying them results in a Boolean value that indicates whether they hold true in this case.

Strings can be compared in the same way.

	console.log("Aardvark" < "Zoroaster")
	// → true

Other similar operators are >= (greater than or equal to), <= (less than or equal to), == (equal to), and != (not equal to).

	console.log("Itchy" != "Scratchy")
	// → true

**Logical operators:**

There are also some operations that can be applied to Boolean values themselves. JavaScript supports three logical operators: *and, or*, and *not*. These can be used to “reason” about Booleans.

The && operator represents logical *and*. It is a binary operator, and its result is true only if both the values given to it are true.

	console.log(true && false)
	// → false
	console.log(true && true)
	// → true

The || operator denotes logical or. It produces true if either of the values given to it is true.

	console.log(false || true)
	// → true
	console.log(false || false)
	// → false

Not is written as an exclamation mark (!). It is a unary operator that flips the value given to it:
  
!*true* produces *false* and !*false* gives *true*.

When mixing these Boolean operators with arithmetic and other operators, it is not always obvious when parentheses are needed. In practice, you can usually get by with knowing that of the operators we have seen so far, || has the lowest precedence, then comes &&, then the comparison operators (>, ==, and so on), and then the rest. This order has been chosen such that, in typical expressions like the following one, as few parentheses as possible are necessary:

	1 + 1 == 2 && 10 * 10 > 50

**Ternary operator (AKA Conditional operator):**

The last logical operator I will discuss is not unary, not binary, but *ternary*, operating on *three values*. It is written with a question mark and a colon, like this:

	console.log(true ? 1 : 2);
	// → 1
	console.log(false ? 1 : 2);
	// → 2

This one is called the *conditional operator* (or sometimes just ternary operator since it is the only such operator in the language). The value on the left of the question mark “picks” which of the other two values will come out. When it is true, the middle value is chosen, and when it is false, the value on the right comes out.

————————————

## Expression: 
Anything that produces a value is an expression in JavaScript. A fragment of code that produces a value is called an expression. Every value that is written literally (such as 22 or "psychoanalysis") is an expression. An expression between parentheses is also an expression, as is a binary operator applied to two expressions or a unary operator applied to one.

## Statement:
If an expression compares to a sentence fragment (In human language), *a JavaScript statement corresponds to a full sentence in a human language*. A program is simply a list of statements.

The simplest kind of statement is an expression with a semicolon after it. This is a program:

	1;
	!false;

An expression can be content to just produce a value. A statement stands on its own and amounts to something only if it affects the world. It could display something on the screen—that counts as changing the world—or it could change the internal state of the machine in a way that will affect the statements that come after it. These changes are called *side effects*. The statements in the previous example just produce the values 1 and true and then immediately throw them away. This leaves no impression on the world at all. When executing the program, nothing observable happens.

## Program:
A program is simply a list of statements.
The simplest kind of statement is an expression with a semicolon after it. This is a program:

	1;
	!false;

## Variable:
How does a program keep an internal state? How does it remember things? We have seen how to produce new values from old values, but this does not change the old values, and the new value has to be immediately used or it will dissipate again. To catch and hold values, JavaScript provides a thing called a variable.

Many languages will stop you, or at least warn you, when you are defining a variable with a name that is already taken. JavaScript does neither, so be careful.

## Keywords (Reserved words):
Words with a special meaning, such as var, are keywords, and they may not be used as variable names. There are also a number of words that are “reserved for use” in future versions of JavaScript. These are also officially not allowed to be used as variable names, though some JavaScript environments do allow them. The full list of keywords and reserved words is rather long:

	break case catch class const continue debugger
	default delete do else enum export extends false
	finally for function if implements import in
	instanceof interface let new null package private
	protected public return static super switch this
	throw true try typeof var void while with yield

## The Environment:
The collection of variables and their values that exist at a given time is called the environment. When a program starts up, this environment is not empty. It always contains variables that are part of the language standard, and most of the time, it has variables that provide ways to interact with the surrounding system. For example, in a browser, there are variables and functions to inspect and influence the currently loaded website and to read mouse and keyboard input.

# Functions

**Summary of contents:** 

A lot of the values provided in the default environment have the type *function*. A function is a piece of program wrapped in a value. Such values can be applied in order to run the wrapped program.

The *function* keyword, when used as an expression, can create a function value. When used as a statement, it can be used to declare a variable and give it a function as its value.

	// Create a function value f
	var f = function(a) {
	  console.log(a + 2);
	};
	
	// Declare g to be a function
	function g(a, b) {
	  return a * b * 3.5;
	}

A key aspect in understanding functions is understanding local scopes. Parameters and variables declared inside a function are local to the function, re-created every time the function is called, and not visible from the outside. Functions declared inside another function have access to the outer function’s local scope.

Separating the tasks your program performs into different functions is helpful. You won’t have to repeat yourself as much, and functions can make a program more readable by grouping code into conceptual chunks, in the same way that chapters and sections help organize regular text.

**Defining a function:**

A function definition is just a regular variable definition where the value given to the variable happens to be a function. For example, the following code defines the variable square to refer to a function that produces the square of a given number:

	var square = function(x) {
	  return x * x;
	};
	
	console.log(square(12));
	// → 144

A function is created by an expression that starts with the keyword function. Functions have a set of *parameters* (in this case, only x) and a body, which contains the statements that are to be executed when the function is called. The function body must always be wrapped in braces, even when it consists of only a single statement (as in the previous example).

*A function can have multiple parameters or no parameters at all*. In the following example, makeNoise does not list any parameter names, whereas power lists two:

	var makeNoise = function() {
	  console.log("Pling!");
	};
	
	makeNoise();
	// → Pling!
	
	var power = function(base, exponent) {
	  var result = 1;
	  for (var count = 0; count < exponent; count++)
	    result *= base;
	  return result;
	};
	
	console.log(power(2, 10));
	// → 1024

*Some functions produce a value, such as power and square, and some don’t, such as makeNoise, which produces only a side effect*. A *return* statement determines the value the function returns. When control comes across such a statement, it immediately jumps out of the current function and gives the returned value to the code that called the function. The *return* keyword without an expression after it will cause the function to return *undefined*.

**Parameters and Scopes:**

The parameters to a function behave like regular variables, *but their initial values are given by the caller of the function, not the code in the function itself*.

An important property of functions is that the *variables created inside of them, including their parameters, are local to the function*. This means, for example, that the *result* variable in the *power function* example will be newly created every time the function is called, and these separate incarnations do not interfere with each other.

This “localness” of variables applies only to the parameters and to variables declared with the var keyword inside the function body. Variables declared outside of any function are called global, because they are visible throughout the program. It is possible to access such variables from inside a function, as long as you haven’t declared a local variable with the same name.

**Nested scope:**

JavaScript distinguishes not just between *global* and *local* variables. Functions can be created inside other functions, producing several degrees of locality.

**The global object**

The global scope, the space in which global variables live, can also be approached as an object in JavaScript. Each global variable is present as a property of this object. In browsers, the global scope object is stored in the window variable.

	var myVar = 10;
	console.log("myVar" in window);
	// → true
	console.log(window.myVar);
	// → 10

**Functions as values:**

Function variables usually simply act as names for a specific piece of the program. Such a variable is defined once and never changed. This makes it easy to start confusing the function and its name.

But the two are different. A function value can do all the things that other values can do—you can use it in arbitrary expressions, not just call it. *It is possible to store a function value in a new place, pass it as an argument to a function, and so on*. Similarly, *a variable that holds a function* is still just a *regular variable and can be assigned a new value*, like so:

	var launchMissiles = function(value) {
	  missileSystem.launch("now");
	};
	if (safeMode)
	  launchMissiles = function(value) {/* do nothing */};

**Declaration notation (Function declaration):**

There is a slightly shorter way to say “var square = function…”. The function keyword can also be used at the start of a statement, as in the following:

	function square(x) {
	  return x * x;
	}

This is a function declaration. The statement defines the variable square and points it at the given function. So far so good. There is one subtlety with this form of function definition, however.

	console.log("The future says:", future());
	
	function future() {
	  return "We STILL have no flying cars.";
	}

*This code works, even though the function is defined below the code that uses it. This is because function declarations are not part of the regular top-to-bottom flow of control*. They are conceptually moved to the top of their scope and can be used by all the code in that scope. This is sometimes useful because it gives us the freedom to order code in a way that seems meaningful, without worrying about having to define all functions above their first use.

What happens when you put such a function definition inside a conditional (if) block or a loop? *Well, don’t do that*. Different JavaScript platforms in different browsers have traditionally done different things in that situation, *and the latest standard actually forbids it*. If you want your programs to behave consistently, only use this form of function-defining statements in the outermost block of a function or program.

	function example() {
	  function a() {} // Okay
	  if (something) {
	    function b() {} // Danger!
	  }
	}

**Optional Arguments:**

The following code is allowed and executes without any problem:

	alert("Hello", "Good Evening", "How do you do?");

The function alert officially accepts only one argument. Yet when you call it like this, it doesn’t complain. It simply ignores the other arguments and shows you “Hello”.

JavaScript is extremely broad-minded about the number of arguments you pass to a function. If you pass too many, the extra ones are ignored. If you pass too few, the missing parameters simply get assigned the value *undefined*.

The upside is that this behavior can be used to have a function take *“optional” arguments*. For example, the following version of power can be called either with two arguments or with a single argument, in which case the exponent is assumed to be two, and the function behaves like square.

	function power(base, exponent) {
	  if (exponent == undefined)
	    exponent = 2;
	  var result = 1;
	  for (var count = 0; count < exponent; count++)
	    result *= base;
	  return result;
	}
	
	console.log(power(4));
	// → 16
	console.log(power(4, 3));
	// → 64

**The Arguments Object**

Whenever a function is called, *a special variable named arguments is added to the environment in which the function body runs*. This variable refers to an object that holds all of the arguments passed to the function.

**Closure:**

The ability to treat functions as values, combined with the fact that local variables are “re-created” every time a function is called, brings up an interesting question. What happens to local variables when the function call that created them is no longer active?

The following code shows an example of this. It defines a function, *wrapValue*, which creates a *local variable*. *It then returns a function that accesses and returns this local variable*.

	function wrapValue(n) {
	  var localVariable = n;
	  return function() { return localVariable; };
	}
	
	var wrap1 = wrapValue(1);
	var wrap2 = wrapValue(2);
	console.log(wrap1());
	// → 1
	console.log(wrap2());
	// → 2

This is allowed and works as you’d hope—the variable can still be accessed. *In fact, multiple instances of the variable can be alive at the same time*. This is another good illustration of the concept that *local variables really are re-created for every call—different calls can’t trample on one another’s local variables*.

This feature—being able to reference a specific instance of local variables in an enclosing function—is called closure. A function that “closes over” some local variables is called a closure. This behaviour not only frees you from having to worry about lifetimes of variables but also allows for some creative use of function values.

With a slight change, we can turn the previous example into a way to create functions that multiply by an arbitrary amount.

	function multiplier(factor) {
	  return function(number) {
	    return number * factor;
	  };
	}
	
	var twice = multiplier(2);
	console.log(twice(5));
	// → 10
	

The explicit *localVariable* from the *wrapValue* example isn’t needed since a parameter is itself a local variable.

*Thinking about programs like this takes some practice*. A good mental model is to think of the function keyword as “freezing” the code in its body and wrapping it into a package (the function value). So when you read return function(...) {...}, think of it as returning a handle to a piece of computation, frozen for later use.

In the example, multiplier returns a frozen chunk of code that gets stored in the twice variable. The last line then calls the value in this variable, causing the frozen code (return number * factor;) to be activated. It still has access to the factor variable from the multiplier call that created it, and in addition it gets access to the argument passed when unfreezing it, 5, through its number parameter.

**Recursion (Functions calling itself):**

It is perfectly okay for a function to call itself, as long as it takes care not to overflow the stack. A function that calls itself is called *recursive*. Recursion allows some functions to be written in a different style. Take, for example, this alternative implementation of power:

	function power(base, exponent) {
	  if (exponent == 0)
	    return 1;
	  else
	    return base * power(base, exponent - 1);
	}
	
	console.log(power(2, 3));
	// → 8

This is rather close to the way mathematicians define exponentiation and arguably describes the concept in a more elegant way than the looping variant does. The function calls itself multiple times with different arguments to achieve the repeated multiplication.

But this implementation has one important problem: in typical JavaScript implementations, *it’s about 10 times slower than the looping version*. Running through a simple loop is a lot cheaper than calling a function multiple times. Often, though, a program deals with such complex concepts that giving up some efficiency in order to make the program more straightforward becomes an attractive choice.

Recursion is not always just a less-efficient alternative to looping. Some problems are much easier to solve with recursion than with loops. Most often these are problems that require exploring or processing several “branches”, each of which might branch out again into more branches.

**Growing functions (Re-usable functions):**

There are two more or less natural ways for functions to be introduced into programs.

The first is that you find yourself writing very similar code multiple times. We want to avoid doing that since having more code means more space for mistakes to hide and more material to read for people trying to understand the program. So we take the repeated functionality, find a good name for it, and put it into a function.

The second way is that you find you need some functionality that you haven’t written yet and that sounds like it deserves its own function. You’ll start by naming the function, and you’ll then write its body. You might even start writing code that uses the function before you actually define the function itself.

How difficult it is to find a good name for a function is a good indication of how clear a concept it is that you’re trying to wrap.

How smart and versatile should our function be? We could write anything from a terribly simple function that simply pads a number so that it’s three characters wide to a complicated generalised number-formatting system that handles fractional numbers, negative numbers, alignment of dots, padding with different characters, and so on.

A useful principle is not to add cleverness unless you are absolutely sure you’re going to need it. It can be tempting to write general “frameworks” for every little bit of functionality you come across. Resist that urge. You won’t get any real work done, and you’ll end up writing a lot of code that no one will ever use.

**Functions and side effects**

*Functions can be roughly divided into those that are called for their side effects and those that are called for their return value*. (Though it is definitely also possible to have both side effects and return a value.)

The first helper function in the farm example, printZeroPaddedWithLabel, is called for its side effect: it prints a line. The second version, zeroPad, is called for its return value. It is no coincidence that the second is useful in more situations than the first. *Functions that create values are easier to combine in new ways than functions that directly perform side effects*.

	A *pure function* is a specific kind of value-producing function that not only has no side effects but also doesn’t rely on side effects from other code. A pure function has the pleasant property that, when called with the same arguments, it always produces the same value (and doesn’t do anything else). 

	Nonpure functions might return different values based on all kinds of factors and have side effects that might be hard to test and think about.

## Methods (Properties that hold functions as its value)

Methods are simply *properties* that hold *function values*. This is a simple method:

	var rabbit = {};
	rabbit.speak = function(line) {
	  console.log("The rabbit says '" + line + "'");
	};
	
	rabbit.speak("I'm alive.");
	// → The rabbit says 'I'm alive.'

Usually a method needs to do something with the object it was called on. When a function is called as a method (looked up as a property and immediately called, as in *object.method()* )the special variable ***this*** in its body will point to the object that it was called on.

	function speak(line) {
	  console.log("The " + this.type + " rabbit says '" + line + "'");
	}
	var whiteRabbit = {type: "white", speak: speak};
	var fatRabbit = {type: "fat", speak: speak};
	
	whiteRabbit.speak("Oh my ears and whiskers, " + "how late it's getting!");
	
	// → The white rabbit says 'Oh my ears and whiskers, how late it's getting!'
	
	fatRabbit.speak("I could sure use a carrot right now.");
	
	// → The fat rabbit says 'I could sure use a carrot right now.'

The code uses the *this* keyword to output the type of rabbit that is speaking.

The code uses the *this* keyword to output the type of rabbit that is speaking. Recall that the *apply* and *bind* methods both take a first argument that can be used to simulate method calls. *This first argument is in fact used to give a value to* ***this***.

There is a method similar to *apply*, called *call*. It also calls the function it is a method of but takes its arguments normally, rather than as an array. Like apply and bind, call can be passed a specific this value.

	speak.apply(fatRabbit, ["Burp!"]);
	// → The fat rabbit says 'Burp!'
	speak.call({type: "old"}, "Oh my.");
	// → The old rabbit says 'Oh my.' 


## Return Values: 
Showing a dialog box or writing text to the screen is a side effect. A lot of functions are useful because of the side effects they produce. Functions may also produce values, and in that case, they don’t need to have a side effect to be useful. When a function produces a value, it is said to return that value. Anything that produces a value is an expression in JavaScript, which means function calls can be used within larger expressions.


## Mutability

We’ve seen that object values can be modified. The types of values discussed in earlier chapters, such as *numbers, strings, and Booleans*, are all *immutable*—it is impossible to change an existing value of those types. You can combine them and derive new values from them, but for example, when you take a specific string value, that value will always remain the same. The text inside it cannot be changed.

If you have reference to a string that contains "cat", it is not possible for *other code to change a character in that string* to make it spell "rat”.

When we have two numbers, 120 and 120, we can consider them precisely the same number, whether or not they *refer to the same physical bits*. But with objects, there is a difference between *having two references to the same object* and *having two different objects that contain the same properties.*

Consider the following code:

	var object1 = {value: 10};
	var object2 = object1;
	var object3 = {value: 10};
	
	console.log(object1 == object2);
	// → true
	console.log(object1 == object3);
	// → false
	
	object1.value = 15;
	console.log(object2.value);
	// → 15
	console.log(object3.value);
	// → 10

The *object1* and *object2* variables grasp the same object. The variable *object3* points to a different object, which initially contains the same properties as *object1* but lives a separate life.

JavaScript’s == operator, when comparing objects, will return true only if both objects are *precisely the same value*. Comparing different objects will return false, even if they have identical contents.

## Control flow:
When your program contains more than one statement, the statements are executed, predictably, from top to bottom. Executing statements in straight-line order isn’t the only option we have. An alternative is conditional execution, where we choose between two different routes based on a Boolean value (left or right, true or false - then do this).

## The Call Stack:

It will be helpful to take a closer look at the way control flows through functions. Here is a simple program that makes a few function calls:

	1  function greet(who) {
	2    console.log("Hello " + who);
	3  }
	4  greet("Harry");
	5  console.log("Bye");

A run through this program goes roughly like this: the call to greet causes control to jump to the start of that function (line 2). It calls console.log, which takes control, does its job, and then returns control to line 2. Then it reaches the end of the greet function, so it returns to the place that called it, at line 4. The line after that calls console.log again.

We could show the flow of control schematically like this:

	top
	   greet
	        console.log
	   greet
	top
	   console.log
	top 

Because a function has to jump back to the place of the call when it returns, the computer must remember the context from which the function was called. In one case, console.log has to jump back to the greet function. In the other case, it jumps back to the end of the program.

The place where the computer stores this context is the *call stack*. Every time a function is called, the current context is put on top of this “stack”. When the function returns, it removes the top context from the stack and uses it to continue execution.

Storing this stack requires space in the computer’s memory. When the stack grows too big, the computer will fail with a message like “out of stack space” or “too much recursion”. Having a infinite call like the example below will *blow the stack*.

	function chicken() {
	  return egg();
	}
	function egg() {
	  return chicken();
	}
	console.log(chicken() + " came first.");
	// → ??

## Conditional execution:
Conditional execution is written with the *if* keyword in JavaScript. In the simple case, we just want some code to be executed if, and only if, a certain condition holds. For example, in the previous program, we might want to show the square of the input only if the input is actually a number.
(left or right, true or false - if true then do this).


## While and Do loops:
Looping control flow allows us to go back to some point in the program where we were before and repeat it with our current program state. If we combine this with a variable that counts, we can do something like this:

	var number = 0;
	while (number <= 12) {
	  console.log(number);
	  number = number + 2;
	}
	// → 0
	// → 2
	// → 4
	//   … etc

A statement starting with the keyword *while* creates a loop. The word while is followed by an expression in parentheses and then a statement, much like if. The loop executes that statement as long as the expression produces a value that is true when converted to Boolean type.

## For Loop:
Because While loops pattern is so common, JavaScript and similar languages provide a slightly shorter and more comprehensive form, the for loop.

	for (var number = 0; number <= 12; number = number + 2)
	  console.log(number);
	// → 0
	// → 2
	//   … etc

This program is exactly equivalent to the earlier even-number-printing example. The only change is that all the statements that are related to the “state” of the loop are now grouped together.

The parentheses after a for keyword must contain two semicolons. The part before the first semicolon initializes the loop, usually by defining a variable. The second part is the expression that checks whether the loop must continue. The final part updates the state of the loop after every iteration. In most cases, this is shorter and clearer than a while construct.

# Data Structures: Objects and Arrays (IMPORTANT)

**Summary**

Objects and arrays (which are a specific kind of object) provide ways to group several values into a single value. 

Most *values* (Strings, Numbers, Booleans etc) in JavaScript have *properties*, the exceptions being *null* and *undefined*. Properties are accessed using *value.propName* or *value["propName”]*. 

Objects tend to use names for their properties and store more or less a fixed set of them. 

Arrays, on the other hand, usually contain varying numbers of conceptually identical values that use numbers (starting from index of 0) as the names of their properties.

There are some named properties in arrays, such as *length* and a number of *methods*. *Methods* are *functions* that live in properties and (usually) act on the value they are a property of.

Objects can also serve as maps, associating values with names. The *in* operator can be used to find out whether an object contains a property with a given name. The same keyword can also be used in a for loop (for (var name *in* object)) to loop over an object’s properties.

———————————

**Building structure from values**

Numbers, Booleans, and strings are the bricks that *data structures* are built from. But you can’t make much of a house out of a single brick. *Objects* allow us to group values (including other objects) together and thus build more complex structures.

This chapter will add a basic understanding of data structures to your toolkit.

To work with a chunk of digital data, we’ll first have to find a way to represent it in our machine’s memory. Say, as a simple example, that we want to represent a collection of numbers: 2, 3, 5, 7, and 11. We could store it as a string: “2 3 5 7 11” but this is not helpful…

**Arrays:**

Fortunately, JavaScript provides a data type specifically for storing sequences of values. It is called an array and is written as a list of values between square brackets, separated by commas.

	var listOfNumbers = [2, 3, 5, 7, 11];
	console.log(listOfNumbers[1]);
	// → 3
	console.log(listOfNumbers[1 - 1]);
	// → 2

The notation for getting at the elements inside an array also uses square brackets. A pair of square brackets immediately after an expression, with another expression inside of them, will look up the element in the left-hand expression that corresponds to the index given by the expression in the brackets. The first index of an array is zero, not one.

**Properties (Properties of parent values)**

We’ve seen a few suspicious-looking expressions like *myString.length* (to get the length of a string) and *Math.max* (the maximum function) in past examples. These are expressions that access a *property* of a parent *value*.

In the first case, we access the *length* property of the value in *myString*.

*Almost all JavaScript values have properties*. The exceptions are *null* and *undefined*. If you try to access a property on one of these nonvalues, you get an error.

	null.length;
	// → TypeError: Cannot read property 'length' of null

**Accessing properties (with dots or square brackets):**

The two most common ways to access properties in JavaScript are with a dot and with square brackets.

Both *value.x* and *value[x]* access a property on *value* —but not necessarily the same property. 

The difference is in how x is interpreted. When using a dot, the part after the dot must be a valid *variable name*, and it directly names the property. When using square brackets, the expression between the brackets is *evaluated* to get the property name. 

**IMPORTANT**: Whereas *value.x* fetches the property of value named “x”, instead, *value[x*] tries to evaluate the *expression* x and uses the result as the property name.

So if you know that the property you are interested in is called “length”, you say *value.length*.

If you want to *extract the property named by the value* held in the variable i, you say *value[i]*.

Because property names can be any string, *if you want to access a property named “2” or “John Doe*”, you must use square brackets: *value[2*] or *value["John Doe”]*.

This is the case because “2” nor “John Doe” is NOT a valid *variable name* (but a property) and so cannot be accessed through dot notation. *The elements in an array are stored in properties*.

**Methods**

Both string and array objects contain, in addition to the *length* property, a number of properties that refer to *function values* also known as methods.

	var doh = "Doh";
	console.log(typeof doh.toUpperCase);
	// → function
	console.log(doh.toUpperCase());
	// → DOH   

Every *string* has a *toUpperCase* property. When called, it will return a copy of the string, in which all letters have been converted to uppercase. There is also toLowerCase. You can guess what that does.

Properties that contain *functions* are generally called *methods of the value they belong to*. As in, “toUpperCase is a method of a string”.

	var mack = [];
	mack.push("Mack");
	mack.push("the", "Knife");
	console.log(mack);
	// → ["Mack", "the", "Knife"]

**Objects:**

Back to the weresquirrel. A set of daily log entries can be represented as an array. But the entries do not consist of just a number or a string—each entry needs to store a list of activities and a Boolean value that indicates whether Jacques turned into a squirrel. Ideally, we would like to group these values together into a single value and then put these grouped values into an array of log entries.

Values of the type *object* are *arbitrary collections of properties*, and we can add or remove these properties as we please. One way to create an object is by using a curly brace notation.

	var day1 = {
	  squirrel: false,
	  events: ["work", "touched tree", "pizza", "running",
	           "television"]
	};
	
	console.log(day1.squirrel);
	// → false
	console.log(day1.wolf);
	// → undefined
	day1.wolf = true;
	console.log(day1.wolf);
	// → true

Inside the curly braces, we can give a list of properties separated by commas. Each property is written as a *name*, followed by a *colon*, followed by an *expression that provides a value for the property*. Properties whose names are not valid variable names or valid numbers have to be quoted.

	var descriptions = {
	  work: "Went to work",
	  "touched tree": "Touched a tree"
	};


This means that curly braces have *two* meanings in JavaScript. At the start of a statement, they start a block of statements. In any other position, they describe an *object*.

Reading a property that doesn’t exist will produce the value *undefined*, which happens the first time we try to read the wolf property in the previous example.

It is possible to assign a value to a property expression with the = operator. This will replace the property’s value if it already existed or create a new property on the object if it didn’t.

**Property Bindings:**

To briefly return to our tentacle model of variable bindings—*property bindings* are similar. They *grasp* values, but other variables and properties might be holding onto those same values.

The *delete* operator cuts off a binding. It is a *unary operator* that, when applied to a property access expression, will remove the named property from the object.

	var anObject = {left: 1, right: 2};
	console.log(anObject.left);
	// → 1
	delete anObject.left;
	console.log(anObject.left);
	// → undefined
	console.log("left" in anObject);
	// → false
	console.log("right" in anObject);
	// → true

The binary *in* operator, when applied to a string and an object, returns a Boolean value that indicates whether that object has that property. The difference between setting a property to *undefined* and actually deleting it is that:

In the first case, the object still has the property (it just doesn’t a value).

In the second case the property is no longer present and in will return *false*.

Arrays, then, *are just a kind of object* specialized for storing sequences of things. If you evaluate *typeof* [1, 2], this produces "object".

**Objects as maps**

A better way is to use object properties named after the event types. We can use the square bracket access notation to create and read the properties and can use the *in* operator to test whether a given property exists.

	var map = {};
	function storePhi(event, phi) {
	  map[event] = phi;
	}
	
	storePhi("pizza", 0.069);
	storePhi("touched tree", -0.081);
	console.log("pizza" in map);
	// → true
	console.log(map["touched tree"]);
	// → -0.081	

A *map* is a way to go from values in one domain to corresponding values in another domain.

**Further on Arrays, it’s properties and it’s objects**

Before finishing up this chapter, I want to introduce you to a few more object-related concepts. We’ll start by introducing some generally useful array methods.

We saw *.push* and *.pop*, which add and remove elements at the end of an array. The corresponding methods for adding and removing things at the start of an array are called *.unshift* and *.shift*.

	var todoList = [];
	function rememberTo(task) {
	  todoList.push(task);
	}
	function whatIsNext() {
	  return todoList.shift();
	}
	function urgentlyRememberTo(task) {
	  todoList.unshift(task);
	}

Another fundamental method is slice, which takes a start index and an end index and returns an array that has only the elements between those indices. The start index is inclusive, the end index exclusive.

	console.log([0, 1, 2, 3, 4].slice(2, 4));
	// → [2, 3]
	console.log([0, 1, 2, 3, 4].slice(2));
	// → [2, 3, 4]

When the end index is not given, slice will take all of the elements after the start index. Strings also have a slice method, which has a similar effect.

The concat method can be used to glue arrays together, similar to what the + operator does for strings. The following example shows both concat and slice in action.

**Strings and their properties**

We can read properties like *length* and *toUpperCase* from string values. But if you try to add a new property, it doesn’t stick.

	var myString = "Fido";
	myString.myProperty = "value";
	console.log(myString.myProperty);
	// → undefined

Values of type *string, number, and Boolean are not objects*, and though the language doesn’t complain if you try to set new properties on them, it doesn’t actually store those properties. *The values are immutable and cannot be changed*.

But these types do have some built-in properties. Every string value has a number of methods. The most useful ones are probably *slice* and *indexOf*, which resemble the array methods of the same name.

	console.log("coconuts".slice(4, 7));
	// → nut
	console.log("coconut".indexOf("u"));
	// → 5

One difference is that a string’s indexOf can take a string containing more than one character, whereas the corresponding array method looks only for a single element.

One difference is that a string’s indexOf can take a string containing more than one character, whereas the corresponding array method looks only for a single element.

console.log("one two three".indexOf("ee"));
// → 11

## The Function Arguments Object

Whenever a function is called, *a special variable named arguments is added to the environment in which the function body runs*. This variable refers to an object that holds all of the arguments passed to the function.

Remember that in JavaScript you are allowed to pass more (or fewer) arguments to a function than the number of parameters the function itself declares.

	function noArguments() {}
	noArguments(1, 2, 3); // This is okay
	function threeArguments(a, b, c) {}
	threeArguments(); // And so is this

The arguments object has a length property that tells us the number of arguments that were really passed to the function. It also has a property for each argument, named 0, 1, 2, and so on.

If that sounds a lot like an array to you, you’re right, it is a lot like an array. But this object, unfortunately, does not have any array methods (like slice or indexOf), so it is a little harder to use than a real array.

	function argumentCounter() {
	  console.log("You gave me", arguments.length, "arguments.");
	}
	argumentCounter("Straw man", "Tautology", "Ad hominem");
	// → You gave me 3 arguments.

Some functions can take any number of arguments, like console.log. These typically loop over the values in their arguments object. They can be used to create very pleasant interfaces. For example:

	addEntry(["work", "touched tree", "pizza", "running", "television"], false);
 
Since he is going to be calling this function a lot, we could create an alternative that is easier to call.

	function addEntry(squirrel) {
	  var entry = {events: [], squirrel: squirrel};
	  for (var i = 1; i < arguments.length; i++)
	    entry.events.push(arguments[i]);
	  journal.push(entry);
	}
	addEntry(true, "work", "touched tree", "pizza",
	         "running", "television");

This version reads its first argument (squirrel) in the normal way and then goes over the rest of the arguments (the loop starts at index 1, skipping the first) to gather them into an array.

**The Math object**

As we’ve seen, *Math* is a grab-bag of number-related utility functions, such as Math.max (maximum), Math.min (minimum), and Math.sqrt (square root).

The Math object is used simply as a container to group a bunch of related functionality. There is only one Math object, and it is almost never useful as a value. Rather, it provides a namespace so that all these functions and values do not have to be global variables as having too many global variables “pollutes” the namespace. 

Back to the Math object. If you need to do trigonometry, Math can help. It contains *cos* (cosine), *sin* (sine), and *tan* (tangent), as well as their inverse functions, *acos*, *asin*, *and* atan, respectively. The number π (pi)—or at least the closest approximation that fits in a JavaScript number—is available as *Math.PI*. (There is an old programming tradition of writing the names of constant values in all caps.)

	function randomPointOnCircle(radius) {
	  var angle = Math.random() * 2 * Math.PI;
	  return {x: radius * Math.cos(angle),
	          y: radius * Math.sin(angle)};
	}
	console.log(randomPointOnCircle(2));
	// → {x: 0.3667, y: 1.966}

The previous example uses Math.random. This is a function that returns a new pseudorandom number between zero (inclusive) and one (exclusive) every time you call it.

**LASTLY: The global object**

The global scope, the space in which global variables live, can also be approached as an object in JavaScript. Each global variable is present as a property of this object. In browsers, the global scope object is stored in the window variable.

	var myVar = 10;
	console.log("myVar" in window);
	// → true
	console.log(window.myVar);
	// → 10

# Prototypes (The Alpha-Omega Hidden Object)

**Summary**

So objects are more complicated than I initially portrayed them. They have **prototypes**, which are other (hidden) objects, and will act as if they have properties they don’t have as long as the prototype has that property. Simple objects have *Object.prototype* as their prototype.

**Constructors**, which are functions whose names usually start with a capital letter, can be used with the new operator to create new objects. The new object’s prototype will be the object found in the prototype property of the constructor function. You can make good use of this by putting the properties that all values of a given type share into their prototype. The instanceof operator can, given an object and a constructor, tell you whether that object is an instance of that constructor.

One useful thing to do with objects is to specify an interface for them and tell everybody that they are supposed to talk to your object only through that interface. The rest of the details that make up your object are now encapsulated, hidden behind the interface.

Once you are talking in terms of interfaces, who says that only one kind of object may implement this interface? Having different objects expose the same interface and then writing code that works on any object with the interface is called polymorphism. It is very useful.

When implementing multiple types that differ in only some details, it can be helpful to simply make the prototype of your new type derive from the prototype of your old type and have your new constructor call the old one. This gives you an object type similar to the old type but for which you can add and override properties as you see fit.

————————————

**Prototypes**

In addition to their set of properties, almost all objects also have a prototype. A prototype is another object that is used as a fallback source of properties. When an object gets a request for a property that it does not have, its prototype will be searched for the property, then the prototype’s prototype, and so on.

Watch closely.

	var empty = {};
	console.log(empty.toString);
	// → function toString(){…}
	console.log(empty.toString());
	// → [object Object]

I just pulled a property out of an empty object. Magic!

So who is the prototype of that empty object? It is the great ancestral prototype, the entity behind almost all objects, ***Object.prototype***.

	console.log(Object.getPrototypeOf({}) ==
	            Object.prototype);
	// → true
	console.log(Object.getPrototypeOf(Object.prototype));
	// → null


As you might expect, the Object.getPrototypeOf function returns the prototype of an object.

The prototype relations of JavaScript objects form a tree-shaped structure, and at the root of this structure sits *Object.prototype*. It provides a few methods that show up in all objects, such as *toString*, which converts an object to a string representation.

Many objects don’t directly have *Object.prototype* as their prototype, but instead have another object, which provides its own default properties. Functions derive from *Function.prototype*, and arrays derive from *Array.prototype*.

	console.log(Object.getPrototypeOf(isNaN) ==
	            Function.prototype);
	// → true
	console.log(Object.getPrototypeOf([]) ==
	            Array.prototype);
	// → true

Such a prototype object will itself have a prototype, often *Object.prototype*, so that it still indirectly provides methods like *toString*.

The *Object.getPrototypeOf* function obviously returns the prototype of an object. You can use *Object.create* to create an object with a specific prototype.

**IMPORTANT Explanation (Very Useful):**

	var protoRabbit = {
	  speak: function(line) {
	    console.log("The " + this.type + " rabbit says '" +
	                line + "'");
	  }
	};
	var killerRabbit = Object.create(protoRabbit);
	killerRabbit.type = "killer";
	killerRabbit.speak("SKREEEE!");
	// → The killer rabbit says 'SKREEEE!'

The “proto” rabbit acts as a container for the properties that are shared by all rabbits. An individual rabbit object, like the killer rabbit, contains properties that apply only to itself—in this case its type—and derives shared properties from its prototype.

## Constructors (Kinda act like prototypes)

A more convenient way to create objects that derive from some shared prototype is to use a constructor.

In JavaScript, calling a function with the *new* keyword in front of it causes it to be treated as a constructor. The constructor will have its *this* variable bound to a fresh object, and unless it explicitly returns another object value, this new object will be returned from the call.

**An object created with *new* is said to be an instance of its constructor**.

Here is a simple constructor for rabbits. It is a convention to capitalize the names of constructors so that they are easily distinguished from other functions.

	function Rabbit(type) {
	  this.type = type;
	}
	
	var killerRabbit = new Rabbit("killer");
	var blackRabbit = new Rabbit("black");
	console.log(blackRabbit.type);
	// → black

**IMPORTANT Info about Constructors:**

Constructors (in fact, all functions) automatically get a property named *prototype*, which by default holds a plain, empty object that derives from *Object.prototype*.

Every instance created with this constructor will have this object as its prototype. So to add a speak method to rabbits created with the Rabbit constructor, we can simply do this:

	Rabbit.prototype.speak = function(line) {
	  console.log("The " + this.type + " rabbit says '" +
	              line + "'");
	};
	blackRabbit.speak("Doom...");
	// → The black rabbit says 'Doom...'

It is important to note the distinction between the way a prototype is associated with a constructor (through its prototype property) and the way objects have a prototype (which can be retrieved with *Object.getPrototypeOf*). 

The actual prototype of a constructor is *Function.prototype* since constructors *are functions*. Its prototype property will be the prototype of instances created through it but is not its own prototype.

**Overriding derived properties**

When you add a property to an object, whether it is present in the prototype or not, the property is added to the object *itself*, (which will henceforth have it as its own property). If there is a property by the same name in the prototype, this property will no longer affect the object. *The prototype itself is not changed*.

	Rabbit.prototype.teeth = "small";
	console.log(killerRabbit.teeth);
	// → small
	killerRabbit.teeth = "long, sharp, and bloody";
	console.log(killerRabbit.teeth);
	// → long, sharp, and bloody
	console.log(blackRabbit.teeth);
	// → small
	console.log(Rabbit.prototype.teeth);
	// → small

**Overriding properties that exist in a prototype is often a useful thing to do**. As the rabbit teeth example shows, it can be used to add exceptional properties in instances of a more generic class of objects, while letting the nonexceptional objects simply take a standard value from their prototype.

It is also used to give the standard function (and array prototypes) a different toString method than the basic object prototype.

	console.log(Array.prototype.toString ==
	            Object.prototype.toString);
	// → false
	console.log([1, 2].toString());
	// → 1,2

**Prototype interference**

A prototype can be used at any time to add new properties and methods to all objects based on it. For example, it might become necessary for our rabbits to dance.

	Rabbit.prototype.dance = function() {
	  console.log("The " + this.type + " rabbit dances a jig.");
	};
	killerRabbit.dance();
	// → The killer rabbit dances a jig.

**But there’s a catch / problem**

That’s convenient. But there are situations where it causes problems. In previous chapters, we used an object as a way to associate values with names by creating properties for the names and giving them the corresponding value as their value. Here’s an example from Chapter 4:

	var map = {};
	function storePhi(event, phi) {
	  map[event] = phi;
	}
	
	storePhi("pizza", 0.069);
	storePhi("touched tree", -0.081);

We can iterate over all *phi* values in the object using a for/in loop and test whether a name is in there using the regular in operator. But unfortunately, the object’s prototype gets in the way.

	Object.prototype.nonsense = "hi";
	for (var name in map)
	  console.log(name);
	// → pizza
	// → touched tree
	// → nonsense  <———— HUH?
	console.log("nonsense" in map);
	// → true
	console.log("toString" in map);
	// → true <———— HUH?
	
	// Delete the problematic property again
	delete Object.prototype.nonsense;

That’s all wrong. There is no event called “nonsense” in our data set. And there definitely is no event called “toString”.

Oddly, toString did not show up in the for/in loop, but the in operator did return true for it. **This is because JavaScript distinguishes between *enumerable* and *nonenumerable* properties**.

All properties that we create by simply assigning to them are *enumerable*. The standard properties in *Object.prototype* are all *nonenumerable*, which is why they do not show up in such a for/in loop.

**Solution to interference**

It is possible to define our own nonenumerable properties by using the *Object.defineProperty* function, which allows us to control the type of property we are creating.

	Object.defineProperty(Object.prototype, "hiddenNonsense",
	                      {enumerable: false, value: "hi"});
	for (var name in map)
	  console.log(name);
	// → pizza
	// → touched tree
	console.log(map.hiddenNonsense);
	// → hi

So now the property is there, but it won’t show up in a loop. That’s good. But we still have the problem with the regular in operator claiming that the *Object.prototype* properties exist in our object. For that, we can use the object’s *hasOwnProperty* method.

	console.log(map.hasOwnProperty("toString"));
	// → false

This method tells us whether the object *itself* has the property, without looking at its prototypes. This is often a more useful piece of information than what the in operator gives us.

When you are worried that someone (some other code you loaded into your program) might have messed with the base object prototype, I recommend you write your for/in loops like this:

	for (var name in map) {
	  if (map.hasOwnProperty(name)) {
	    // ... this is an own property
	  }
	}

**Prototype-less objects**

But the rabbit hole doesn’t end there. What if someone registered the name hasOwnProperty in our map object and set it to the value 42? Now the call to map.hasOwnProperty will try to call the local property, which holds a number, not a function.

In such a case, prototypes just get in the way, and we would actually prefer to have objects without prototypes. We saw the Object.create function, which allows us to create an object with a specific prototype. You are allowed to pass null as the prototype to create a fresh object with no prototype. For objects like map, where the properties could be anything, this is exactly what we want.

	var map = Object.create(null);
	map["pizza"] = 0.069;
	console.log("toString" in map);
	// → false
	console.log("pizza" in map);
	// → true

Much better! We no longer need the hasOwnProperty kludge because all the properties the object has are its own properties. Now we can safely use for/in loops, no matter what people have been doing to Object.prototype.

## Polymorphism

When you call the *String* function, which converts a value to a string, on an object, it will call the *toString* method on that object to try to create a meaningful string to return. I mentioned that some of the standard prototypes (for Arrays, Objects) define their own version of *toString* so they can create a string that contains more useful information than "[object Object]".

This is a simple instance of a powerful idea. When a piece of code is written to work with objects that have a certain interface (in this case, a toString method), any kind of object that happens to support this interface can be plugged into the code, and it will just work.

This technique is called polymorphism—though no actual shape-shifting is involved. Polymorphic code can work with values of different shapes, as long as they support the interface it expects.

**Getting and setting using get and set**

When specifying an interface, it is possible to include properties that are not methods. We could have defined minHeight and minWidth to simply hold numbers. But that’d have required us to compute them in the constructor, which adds code there that isn’t strictly relevant to constructing the object. 

It would cause problems if, for example, the inner cell of an underlined cell was changed, at which point the size of the underlined cell should also change.

This has led some people to adopt a principle of never including *nonmethod* properties in interfaces. 

Rather than directly accessing a simple value property, they’d use *getSomething* and *setSomething* methods to read and write the property. This approach has the downside that you will end up writing—and reading—a lot of additional methods.

Fortunately, JavaScript provides a technique that gets us the best of both worlds. We can specify properties that, from the outside, look like normal properties but secretly have methods associated with them.

	var pile = {
	  elements: ["eggshell", "orange peel", "worm"],
	  get height() {
	    return this.elements.length;
	  },
	  set height(value) {    <—— HERE
	    console.log("Ignoring attempt to set height to", value);
	  }
	};
	
	console.log(pile.height);
	// → 3
	pile.height = 100;
	// → Ignoring attempt to set height to 100

In object literal, **the *get or set* notation for properties allows you to specify a function to be run when the property is read or written**. You can also add such a property to an existing object, for example a prototype, using the *Object.defineProperty* function (which we previously used to create nonenumerable properties).

You can use a similar *set* property, in the object passed to defineProperty, to specify a setter method. 

*When a getter but no setter is defined, writing to the property is simply ignored*.

## Inheritance

Inheritance is a fundamental part of the object-oriented tradition, alongside encapsulation and polymorphism. But while the latter two are now generally regarded as wonderful ideas, inheritance is somewhat controversial.

The main reason for this is that it is often *confused with polymorphism*, sold as a more powerful tool than it really is, and subsequently overused in all kinds of ugly ways. Whereas encapsulation and polymorphism can be used to separate pieces of code from each other, reducing the tangledness of the overall program, inheritance fundamentally ties types together, *creating more tangle*.

You can have polymorphism without inheritance, as we saw. I am not going to tell you to avoid inheritance entirely—I use it regularly in my own programs. But you should see it as a slightly dodgy trick that can help you define new types with little code, not as a grand principle of code organization. A preferable way to extend types is through composition, such as how UnderlinedCell builds on another cell object by simply storing it in a property and forwarding method calls to it in its own methods.

**The instanceof operator**

It is occasionally useful to know whether an object was derived from a specific *constructor*. For this, JavaScript provides a binary operator called *instanceof*.

	console.log(new RTextCell("A") instanceof RTextCell);
	// → true
	console.log(new RTextCell("A") instanceof TextCell);
	// → true
	console.log(new TextCell("A") instanceof RTextCell);
	// → false
	console.log([1] instanceof Array);
	// → true

The operator will see through inherited types. An *RTextCell* is an instance of TextCell because *RTextCell.prototype* derives from *TextCell.prototype*. The operator can be applied to standard constructors like Array. Almost every object is an instance of Object.







